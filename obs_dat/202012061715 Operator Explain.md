
#MYSQL 
<div align="center">
<span class='flair' style='background-color:#F1C40F;color:#000;margin:5px'>
Learning MySQL
</span>
<img width="20" height="20" src="https://www.flaticon.com/svg/static/icons/svg/945/945147.svg">
</div>

<hr>



Оператор EXPLAIN використовується для одержання плану виконання запиту й надає інформацію про те, як оптимізатор СУБД MySQL виконує інструкції SQL-запиту та в якому порядку.

Оператор EXPLAIN працює із запитами SELECT, DELETE, INSERT,
REPLACE і UPDATE;


##### explain statement
```sql
{EXPLAIN | DESCRIBE | DESC}
[EXTENDED | PARTITIONS | FORMAT = {TRADITIONAL | JSON}]
{ SELECT statement | DELETE statement | INSERT statement
| REPLACE statement | UPDATE statement
| FOR CONNECTION connection_id}
```

#template
<mark>Особенности </mark>
> оператор `EXPLAIN ... FOR CONNECTION` відображає план виконання
для SQL-запиту, що виконується в іменованому з’єднанні

> опція `FORMAT` визначає формат висновку: TRADITIONAL – у табличному
форматі (за замовчуванням); JSON – у форматі JSON;

> перед запуском запитів з оператором EXPLAIN рекомендується
виконати інструкцію `ANALYZE TABLE`;

#template
<u>Использование:</u>

##### Text
```sql
EXPLAIN SELECT * FROM categories
```


Результат:
```sql
********************** 1. row **********************
id: 1
select_type: SIMPLE
table: categories
type: ALL
possible_keys: NULL
key: NULL
key_len: NULL
ref: NULL
rows: 4
Extra: 
1 row in set (0.00 sec)
```

- id – порядковый номер для каждого SELECT’а внутри запроса (когда имеется несколько подзапросов)
- select_type – тип запроса SELECT 
	>- SIMPLE — Простой запрос SELECT без подзапросов или UNION’ов
	>- PRIMARY – данный SELECT – самый внешний запрос в JOIN’е
	>- DERIVED – данный SELECT является частью подзапроса внутри FROM
	>- SUBQUERY – первый SELECT в подзапросе
	>- DEPENDENT SUBQUERY – подзапрос, который зависит от внешнего запроса
	>- UNCACHABLE SUBQUERY – не кешируемый подзапрос (существуют определенные условия для того, чтобы запрос кешировался)
	>- UNION – второй или последующий SELECT в UNION’е
	>- DEPENDENT UNION – второй или последующий SELECT в UNION’е, зависимый от внешнего запроса
	>- UNION RESULT – результат UNION’а



- Table – таблица, к которой относится выводимая строка
- Type — указывает на то, как MySQL связывает используемые таблицы. Это одно из наиболее полезных полей в выводе потому, что может сообщать об отсутствующих индексах или почему написанный запрос должен быть пересмотрен и переписан.
Возможные значения:
> - System – таблица имеет только одну строку
> - Const – таблица имеет только одну соответствующую строку, которая проиндексирована. Это наиболее быстрый тип соединения потому, что таблица читается только один раз и значение строки может восприниматься при дальнейших соединениях как константа.
> - Eq_ref – все части индекса используются для связывания. Используемые индексы: PRIMARY KEY или UNIQUE NOT NULL. Это еще один наилучший возможный тип связывания.
> - Ref – все соответствующие строки индексного столбца считываются для каждой комбинации строк из предыдущей таблицы. Этот тип соединения для индексированных столбцов выглядит как использование операторов = или < = >
> - Fulltext – соединение использует полнотекстовый индекс таблицы
>- Ref_or_null – то же самое, что и ref, но также содержит строки со значением null для столбца
>- Index_merge – соединение использует список индексов для получения результирующего набора. Столбец key вывода команды EXPLAIN будет содержать список использованных индексов.
> - Unique_subquery – подзапрос IN возвращает только один результат из таблицы и использует первичный ключ.
> - Index_subquery – тоже, что и предыдущий, но возвращает более одного результата.
> - Range – индекс, использованный для нахождения соответствующей строки в определенном диапазоне, обычно, когда ключевой столбец сравнивается с константой, используя операторы вроде: BETWEEN, IN, >, >=, etc.
> - Index – сканируется все дерево индексов для нахождения соответствующих строк.
> - All – Для нахождения соответствующих строк используются сканирование всей таблицы. Это наихудший тип соединения и обычно указывает на отсутствие подходящих индексов в таблице.


- Possible_keys – показывает индексы, которые могут быть использованы для нахождения строк в таблице. На практике они могут использоваться, а могут и не использоваться. Фактически, этот столбец может сослужить добрую службу в деле оптимизации запросов, т.к значение NULL указывает на то, что не найдено ни одного подходящего индекса .
- Key– указывает на использованный индекс. Этот столбец может содержать индекс, не указанный в столбце possible_keys. В процессе соединения таблиц оптимизатор ищет наилучшие варианты и может найти ключи, которые не отображены в possible_keys, но являются более оптимальными для использования.
- Key_len – длина индекса, которую оптимизатор MySQL выбрал для использования. Например, значение key_len, равное 4, означает, что памяти требуется для хранения 4 знаков. На эту тему вот cсылка
- Ref – указываются столбцы или константы, которые сравниваются с индексом, указанным в поле key. MySQL выберет либо значение константы для сравнения, либо само поле, основываясь на плане выполнения запроса.
- Rows – отображает число записей, обработанных для получения выходных данных. Это еще одно очень важное поле, которое дает повод оптимизировать запросы, особенно те, которые используют JOIN’ы и подзапросы.
- Extra – содержит дополнительную информацию, относящуюся к плану выполнения запроса. Такие значения как “Using temporary”, “Using filesort” и т.д могут быть индикатором проблемного запроса. С полным списком возможных значений вы можете ознакомиться здесь



После EXPLAIN в запросе вы можете использовать ключевое слово EXTENDED и MySQL покажет вам дополнительную информацию о том, как выполняется запрос. Чтобы увидеть эту информацию, вам нужно сразу после запроса с EXTENDED выполнить запрос SHOW WARNINGS. Наиболее полезно смотреть эту информацию о запросе, который выполнялся после каких-либо изменений сделанных оптимизатором запросов.
