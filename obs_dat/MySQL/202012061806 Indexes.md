#MYSQL 

Links
 [Индексы ](https://ruhighload.com/%D0%98%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%8B+%D0%B2+mysql)
 
# Индексы
Индекс представляет собою структуру данных, которые уже отсортированы. При поиске значений эта структура может быть поделена на несколько частей, по методу дерева, или бинарному методу. Например: таблица записей отсортированих по порядку возростания возраста. Нужно найти запись с числом 6. На первой итерации система узнаёт к какой части данных (с 1 до 5) или (с 5 до 10) нужно обращаться. Если 6 то нужно обратиться ко второй части и там искать данные. Для метода  B-Tree структура может быть поделена более подробно.

## <mark>Польза</mark>

Индекс нужен для ускорения процесса поиска информации в базе данных с большим объемом банка данных. Если в таблице свыше 1 млн. записей и нужно осуществить поиск по имени и т.д - будет происходить прохождение по всем записям, сравнивая каждую с заданым  значением. 

## <mark>Недостатки:</mark>
 - увеличивает объем базы данних. Кроме обычных данных, нужно хранить дублирование данные, но для индексов в определённой структуре
 - Команды INSERT будут происходить дольше, поскольку структура данных для интексов так же будут перестраиваться

## <mark>Положительные стороны</mark>
- ускоряют поиск
- ускоряют сортировку ORDER BY


#### Типы индексов:
>B-Tree - 
R-Tree - данные по позиции MyISAM
Hash Index - 
Fulltext Index -  MyISAM, INNODB

## <mark>Создание</mark>

<u>Обычный индекс</u>
>```sql
>CREATE INDEX age ON users(age);
>```
>После этой операции MySQL начнет использовать индекс age для выполнения подобных запросов. Индекс будет использоваться и для выборок по диапазонам значений этой колонки:
>```sql
>SELECT * FROM users WHERE age < 29
>```



<u>Уникальные индексы </u>
>```sql
>SELECT * FROM users WHERE email = 'golotyuk@gmail.com';
>```
>Для такой выборки можно создать для столбца почта индекс
>```sql
>CREATE UNIQUE INDEX email ON users(email)
>```


<u>Составные индексы</u>

>MySQL может использовать только один индекс для запроса (кроме случаев, когда MySQL способен объединить результаты выборок по нескольким индексам). Поэтому, для запросов, в которых используется несколько колонок, необходимо использовать составные индексы.
><br>
> ![[Pasted image 20201206200447.png]]
> 
> Например для запроса типа
> ```sql
> SELECT * FROM users WHERE age = 29 AND gender = 'male'
> ```
> Следует создать индекс 
> ```sql
> CREATE INDEX age_gender ON users(age, gender);
> ```


>Чтобы правильно использовать составные индексы, необходимо понять структуру их хранения. Все работает точно так же, как и для обычного индекса. Но для значений используются значений всех входящих колонок сразу. Для таблицы с такими данными:
![[Pasted image 20201206200710.png]]
значения составного индекса будут такими:
>```sql
age_gender
12male
15female
29male
89tsar
>```

>Это означает, `что очередность колонок в индексе будет играть большую роль.` Обычно колонки, которые используются в условиях WHERE, следует ставить в начало индекса. Колонки из ORDER BY — в конец.

# Поиск по диапазону 

>Например
>```sql
>SELECT * FROM users WHERE age <= 29 AND gender = 'male'
>```
>Тогда MySQL не сможет использовать полный индекс, т.к. значения gender будут отличаться для разных значений колонки age. В этом случае база данных попытается использовать часть индекса (только age), чтобы выполнить этот запрос:

>Сначала будут отфильтрованы все данные, которые подходят под условие age <= 29. Затем, поиск по значению "male" будет произведен без использования индекса.


# Дополнения

>##### alter statement
>```sql
>ALTER TABLE `my`.`fonts` 
>ADD INDEX `font_name` (`fonts_name` ASC) VISIBLE;;
>```


>##### delete index
>```sql
>ALTER TABLE `my`.`fonts` 
>DROP INDEX `font_name` ;;
>```



<br>
<hr>




